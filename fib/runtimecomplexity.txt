Runtime Complexity, Big 'O' Notation
Constant time = 1
  - no matter how many elements we're working with, the algorithm/operation/whatever will always take the same amount of time
  - rarely will such an algorithm exist, its the optimal situation.
  - the holy grail of solutions
Logarithmic time = log(n)
  - you have this if doubling the number of elements you are iterating over doesnt double the amount of work.
  - always assume that searching operations are log(n)
Linear Time = n
  - iterating through all elements in a collection of data. 
  - if you see a for loop spanning from '0' to 'array.length', you probably have 'n', or linear runtime
Quasilinear Time = n * log(n)
  - you have this if doubling the number of elements you are iterating over doesnt double the amount of work.
  - always assume that any sorting operation is n*log(n)
Quadratic Time = n ^ 2
  - every element in a collection has to be compared to every other element. 'the handshake problem'
Exponential Time = 2 ^ n
  - if you add a 'single' element to a collection the processing power required doubles.



Identifying Runtime Complexity
iterating with a simple for loop through a single collection?
  Probably O(n)
Iterating through half a colleciton? half a string...
  still O(n). there are no constants in runtime...
Iterating through two 'different' collections with separate for loops? iterate two strings
  O(n + m) ... n represents the 1st string, m represents the 2nd string.
Two nested for loops iterating over the same collection? nested for loops, big red flag
  O(n ^ 2)
  the steps algorithm, and the pyramid algorithm, specifically the iterative solutions
Two nested for loops iterating over different collections?
  O(n * m) 
Sorting?
  O(n * log(n))
Searching a sorted array?
  O(log(n))

Space complexity is similar to runtime complexity... the math is slightly different.
  how much memory is wrequire by doubling the problem set?


Notes from stack:

Any algorithm where the number of required operations is on the order of the logarithm of the size of the input is O(log n). 
The important thing that big-O analysis tells you is how the execution time of an algorithm changes relative to the size of the input: 
if you double the size of the input, does the algorithm take 1 more step (O(log n)), twice as many steps (O(n)), four times as many 
steps (O(n^2)), etc.

What exactly does log n mean? at each step in an algorithm, you remove half of your remaining choices
The most common attributes of logarithmic running-time function are that:

Only one action will happen when an element is chosen, even if there are several possible actions.
or
the elements on which the action is performed are digits of n...

This is why, for example, looking up people in a phone book is O(log n)...
You don't need to check every person in the phone book to find the right one; 
instead, you can simply divide-and-conquer by looking based on where there name is alphabetically, 
and in every section you only need to explore a subset of the each section before you eventually find someone's phone number.

Of course, a bigger phone book will still take you a longer time, but it won't grow as quickly 
as the proportional increase in the additional size.

We can expand the phone book example to compare other kinds of operations and their running time.
We will assume our phone book has businesses (the "Yellow Pages") which have unique names and 
people (the "White Pages") which may not have unique names. A phone number is assigned to at most 
one person or business. We will also assume that it takes constant time to flip to a specific page.

Here are the running times of some operations we might perform on the phone book, from best to worst:

O(1) (worst case): Given the page that a business's name is on and the business name, find the phone number.

O(1) (average case): Given the page that a person's name is on and their name, find the phone number.

O(log n): Given a person's name, find the phone number by picking a random point about halfway through the part of the book you haven't searched yet, 
then checking to see whether the person's name is at that point. Then repeat the process 
about halfway through the part of the book where the person's name lies. (This is a binary search for a person's name.)

O(n): Find all people whose phone numbers contain the digit "5".

O(n): Given a phone number, find the person or business with that number.

O(n log n): There was a mix-up at the printer's office, and our phone book had all its pages inserted in a random order. 
Fix the ordering so that it's correct by looking at the first name on each page and then putting that page in the appropriate spot in a new, 
empty phone book.

For the below examples, we're now at the printer's office. Phone books are waiting 
to be mailed to each resident or business, and there's a sticker on each phone book 
identifying where it should be mailed to. Every person or business gets one phone book.

O(n log n): We want to personalize the phone book, so we're going to find each person 
or business's name in their designated copy, then circle their name in the book and 
write a short thank-you note for their patronage.

O(n2): A mistake occurred at the office, and every entry in each of the phone 
books has an extra "0" at the end of the phone number. Take some white-out and remove each zero.

O(n Â· n!): We're ready to load the phonebooks onto the shipping dock. 
Unfortunately, the robot that was supposed to load the books has gone haywire: 
it's putting the books onto the truck in a random order! Even worse, it loads 
all the books onto the truck, then checks to see if they're in the right order, 
and if not, it unloads them and starts over. (This is the dreaded bogo sort.)

O(nn): You fix the robot so that it's loading things correctly. The next day, one of your co-workers plays a prank on you and wires the loading dock robot to the automated printing systems. Every time the robot goes to load an original book, the factory printer makes a duplicate run of all the phonebooks! Fortunately, the robot's bug-detection systems are sophisticated enough that the robot doesn't try printing even more copies when it encounters a duplicate book for loading, but it still has to load every original and duplicate book that's been printed.